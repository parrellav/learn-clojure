<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1459539096356">{:repl-history {:ide [], :local [&quot;(vargs 1 2 3 4 5)&quot; &quot;(defn launch\n  \&quot;Launches a spacecraft into the given orbit by initiating a\n   controlled on-axis burn. Does not automatically stage, but\n   does vector thrust, if the craft supports it.\&quot;\n  [craft target-orbit]\n  \&quot;OK, we don't know how to control spacecraft yet.\&quot;)&quot; &quot;(doc launch)&quot; &quot;(meta #'launch)&quot; &quot;(type 2)&quot; &quot;(type type)&quot; &quot;type&quot; &quot;(supers (type type))&quot; &quot;(fn? type)&quot; &quot;(doc type)&quot; &quot;(meta #'type)&quot; &quot;(source type)&quot; &quot;(source +)&quot; &quot;(source def)&quot; &quot;(inc [1 2 3])&quot; &quot;(def number [1 2 3])&quot; &quot;(def numbers [1 2 3])&quot; &quot;(nth numbers 0)&quot; &quot;(inc (nth numbers 0))&quot; &quot;[(inc (nth numbers 0)) (inc (nth numbers 1)) (inc (nth numbers 2))]&quot; &quot;(def numbers [1 2])&quot; &quot;(first [1 2 3])&quot; &quot;(rest [1 2 3])&quot; &quot;(cons 1 [2])&quot; &quot;(cons 1 [2 3])&quot; &quot;(cons 1 [2 3 4])&quot; &quot;(defn inc-first [nums]\n  (cons (inc (first nums))\n        (rest nums)))&quot; &quot;(inc-first [1 2 3 4])&quot; &quot;(inc-first [5])&quot; &quot;(doc if)&quot; &quot;(if true :a :b)&quot; &quot;(if false :a :b)&quot; &quot;(defn inc-first [nums]\n  (if (first nums)\n    (cons (inc (first nums))\n          (rest nums))\n    (list)))&quot; &quot;(inc-first [])&quot; &quot;(inc-first [1 2 3])&quot; &quot;(defn inc-more [nums]\n  (if (first nums)\n    (cons (inc (first nums))\n          (inc-more (rest nums)))\n    (list)))&quot; &quot;(inc-more [1 2 3 4])&quot; &quot;(defn transform-all [f xs]\n  (if (first xs)\n    (cons (f (first xs))\n          (transform-all f (rest xs)))\n    (list)))&quot; &quot;(transform-all inc [1 2 3 4])&quot; &quot;(transform-all keyword [\&quot;bell\&quot; \&quot;hooks\&quot;])&quot; &quot;(transform-all list [:codex :book :manuscript])&quot; &quot;(defn expand [f x count]\n  (if (pos? count)\n    (cons x (expand f (f x) (dec count)))))&quot; &quot;(expand inc 0 10)&quot; &quot;(take 10 (iterate inc 0))&quot; &quot;(take 10 (iterate (fn [x] (if (odd? x) (+ x 1) (/ x 2))) 10))&quot; &quot;(take 5 (iterate (fn [x] (str x \&quot;o\&quot;)) \&quot;y\&quot;))&quot; &quot;(fn [x] (str x \&quot;o\&quot;) \&quot;y\&quot;)&quot; &quot;((fn [x] (str x \&quot;o\&quot;)) \&quot;y\&quot;)&quot; &quot;(take 10 (repeat :hi))&quot; &quot;(take 3 (repeatedly rand))&quot; &quot;(map (fn [n vehicle] (str \&quot;I've got \&quot; n \&quot; \&quot; vehicle \&quot;s\&quot;))\n     [0 200 9]\n     [\&quot;car\&quot; \&quot;train\&quot; \&quot;kiteboard\&quot;])&quot; &quot;(map (fn [index element] (str index \&quot;. \&quot; element))\n     (iterate inc 0)\n     [\&quot;erlang\&quot; \&quot;ruby\&quot; \&quot;haskell\&quot;])&quot; &quot;(doc take-while)&quot; &quot;(defn recursive-factorial [n]\n  (if (zero? n)\n    1\n    (* n (recursive-factorial (dec n)))))&quot; &quot;(recursive-factorial 5)&quot; &quot;(cons 1\n      (cons 2\n            (cons 3\n                  (cons 4 '()))))&quot; &quot;(defn sum [coll]\n  (if (empty? coll)\n    0\n    (+ (first coll)\n       (sum (rest coll)))))&quot; &quot;(sum [1 2 3 4])&quot; &quot;(defn product [coll]\n  (if (empty? coll)\n    1\n    (* (first coll)\n       (product (rest coll)))))&quot; &quot;(product [1])&quot; &quot;(product [1 2])&quot; &quot;(product [0 1 2 3 4])&quot; &quot;(product #{2 3 4})&quot; &quot;(rest [])&quot; &quot;(defn singleton? [coll]\n  (if (empty? coll)\n    false\n    (empty? (rest coll))))\n  &quot; &quot;(singleton? #[2])&quot; &quot;(defn my-last [coll]\n  (if (singleton? coll)\n    coll\n    (my-last (rest coll))))&quot; &quot;(defn my-last [a-seq]\n  (if (empty? a-seq)\n    nil)\n  (if (singleton? a-seq)\n    a-seq\n    (my-last (rest a-seq))))&quot; &quot;(defn my-last [a-seq]\n  (if (empty? a-seq)\n    '())\n  (if (singleton? a-seq)\n    a-seq\n    (my-last (rest a-seq))))&quot; &quot;(source first)&quot; &quot;(defn my-last [a-seq]\n  (if (empty? a-seq)\n    ())\n  (if (singleton? a-seq)\n    a-seq\n    (my-last (rest a-seq))))&quot; &quot;(my-last [1 2])&quot; &quot;(defn my-last [a-seq]\n  (if (empty? a-seq)\n    (first a-seq))\n  (if (singleton? a-seq)\n    a-seq\n    (my-last (rest a-seq))))&quot; &quot;(defn my-last [a-seq]\n  (if-not (empty? a-seq)\n    (if (singleton? a-seq)\n      a-seq\n      (my-last (rest a-seq)))))&quot; &quot;(defn max-element [a-seq]\n  (if-not (empty? a-seq)\n    (if (singleton? a-seq)\n      a-seq\n      (max (first a-seq) (rest a-seq)))))&quot; &quot;(defn max-element [a-seq]\n  (if-not (empty? a-seq)\n    (if (singleton? a-seq)\n      a-seq\n      (max (first a-seq) (max-element (rest a-seq))))))&quot; &quot;(product [])&quot; &quot;(product [1 2 3])&quot; &quot;(product [1 2 3 4])&quot; &quot;(singleton? [1])&quot; &quot;(singleton? [])&quot; &quot;(singleton? [1 2 3])&quot; &quot;(singleton? #{2})&quot; &quot;(my-last [])&quot; &quot;(my-last [1 2 3])&quot; &quot;(my-last [2 5])&quot; &quot;(max-element [])&quot; &quot;(max-element [2])&quot; &quot;(max-element [2 4])&quot; &quot;(max-element [2 4 1 4])&quot; &quot;(max-element [2 4 1 4 8])&quot; &quot;(seq-max [1] [1 2])&quot; &quot;(seq-max [1 2] [3 4])&quot; &quot;(doc count)&quot; &quot;(longest-sequence []) &quot; &quot;(longest-sequence [[1 2] [] [1 2 3]])&quot; &quot;(longest-sequence [[1 2] []])&quot; &quot;(longest-sequence [[1 2]])&quot; &quot;(longest-sequence [[] [1 2]])&quot; &quot;(count [])&quot; &quot;(longest-sequence [[] [1 2] [1 2 3]])&quot;], :remote []}}</component>
</project>