<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1459540642553">{:repl-history {:ide [], :local [&quot;(inc-first [1 2 3])&quot; &quot;(defn inc-more [nums]\n  (if (first nums)\n    (cons (inc (first nums))\n          (inc-more (rest nums)))\n    (list)))&quot; &quot;(inc-more [1 2 3 4])&quot; &quot;(defn transform-all [f xs]\n  (if (first xs)\n    (cons (f (first xs))\n          (transform-all f (rest xs)))\n    (list)))&quot; &quot;(transform-all inc [1 2 3 4])&quot; &quot;(transform-all keyword [\&quot;bell\&quot; \&quot;hooks\&quot;])&quot; &quot;(transform-all list [:codex :book :manuscript])&quot; &quot;(defn expand [f x count]\n  (if (pos? count)\n    (cons x (expand f (f x) (dec count)))))&quot; &quot;(expand inc 0 10)&quot; &quot;(take 10 (iterate inc 0))&quot; &quot;(take 10 (iterate (fn [x] (if (odd? x) (+ x 1) (/ x 2))) 10))&quot; &quot;(take 5 (iterate (fn [x] (str x \&quot;o\&quot;)) \&quot;y\&quot;))&quot; &quot;(fn [x] (str x \&quot;o\&quot;) \&quot;y\&quot;)&quot; &quot;((fn [x] (str x \&quot;o\&quot;)) \&quot;y\&quot;)&quot; &quot;(take 10 (repeat :hi))&quot; &quot;(take 3 (repeatedly rand))&quot; &quot;(map (fn [n vehicle] (str \&quot;I've got \&quot; n \&quot; \&quot; vehicle \&quot;s\&quot;))\n     [0 200 9]\n     [\&quot;car\&quot; \&quot;train\&quot; \&quot;kiteboard\&quot;])&quot; &quot;(map (fn [index element] (str index \&quot;. \&quot; element))\n     (iterate inc 0)\n     [\&quot;erlang\&quot; \&quot;ruby\&quot; \&quot;haskell\&quot;])&quot; &quot;(doc take-while)&quot; &quot;(defn recursive-factorial [n]\n  (if (zero? n)\n    1\n    (* n (recursive-factorial (dec n)))))&quot; &quot;(recursive-factorial 5)&quot; &quot;(cons 1\n      (cons 2\n            (cons 3\n                  (cons 4 '()))))&quot; &quot;(defn sum [coll]\n  (if (empty? coll)\n    0\n    (+ (first coll)\n       (sum (rest coll)))))&quot; &quot;(sum [1 2 3 4])&quot; &quot;(defn product [coll]\n  (if (empty? coll)\n    1\n    (* (first coll)\n       (product (rest coll)))))&quot; &quot;(product [1])&quot; &quot;(product [1 2])&quot; &quot;(product [0 1 2 3 4])&quot; &quot;(product #{2 3 4})&quot; &quot;(rest [])&quot; &quot;(defn singleton? [coll]\n  (if (empty? coll)\n    false\n    (empty? (rest coll))))\n  &quot; &quot;(singleton? #[2])&quot; &quot;(defn my-last [coll]\n  (if (singleton? coll)\n    coll\n    (my-last (rest coll))))&quot; &quot;(defn my-last [a-seq]\n  (if (empty? a-seq)\n    nil)\n  (if (singleton? a-seq)\n    a-seq\n    (my-last (rest a-seq))))&quot; &quot;(defn my-last [a-seq]\n  (if (empty? a-seq)\n    '())\n  (if (singleton? a-seq)\n    a-seq\n    (my-last (rest a-seq))))&quot; &quot;(source first)&quot; &quot;(defn my-last [a-seq]\n  (if (empty? a-seq)\n    ())\n  (if (singleton? a-seq)\n    a-seq\n    (my-last (rest a-seq))))&quot; &quot;(my-last [1 2])&quot; &quot;(defn my-last [a-seq]\n  (if (empty? a-seq)\n    (first a-seq))\n  (if (singleton? a-seq)\n    a-seq\n    (my-last (rest a-seq))))&quot; &quot;(defn my-last [a-seq]\n  (if-not (empty? a-seq)\n    (if (singleton? a-seq)\n      a-seq\n      (my-last (rest a-seq)))))&quot; &quot;(defn max-element [a-seq]\n  (if-not (empty? a-seq)\n    (if (singleton? a-seq)\n      a-seq\n      (max (first a-seq) (rest a-seq)))))&quot; &quot;(defn max-element [a-seq]\n  (if-not (empty? a-seq)\n    (if (singleton? a-seq)\n      a-seq\n      (max (first a-seq) (max-element (rest a-seq))))))&quot; &quot;(product [])&quot; &quot;(product [1 2 3])&quot; &quot;(product [1 2 3 4])&quot; &quot;(singleton? [1])&quot; &quot;(singleton? [])&quot; &quot;(singleton? [1 2 3])&quot; &quot;(singleton? #{2})&quot; &quot;(my-last [])&quot; &quot;(my-last [1 2 3])&quot; &quot;(my-last [2 5])&quot; &quot;(max-element [])&quot; &quot;(max-element [2])&quot; &quot;(max-element [2 4])&quot; &quot;(max-element [2 4 1 4])&quot; &quot;(max-element [2 4 1 4 8])&quot; &quot;(seq-max [1] [1 2])&quot; &quot;(seq-max [1 2] [3 4])&quot; &quot;(doc count)&quot; &quot;(longest-sequence []) &quot; &quot;(longest-sequence [[1 2] [] [1 2 3]])&quot; &quot;(longest-sequence [[1 2] []])&quot; &quot;(longest-sequence [[] [1 2] [1 2 3]])&quot; &quot;(longest-sequence [[] [1 2]])&quot; &quot;(longest-sequence [[1 2]])&quot; &quot;(longest-sequence [])&quot; &quot;(doc cons)&quot; &quot;(my-filter odd? [1 2 3 4])&quot; &quot;(my-filter (fn [x] (&gt; x 9000))&quot; &quot;(my-filter (fn [x] (&gt; x 9000)) [12 49 90 9001])&quot; &quot;(my-filter even? [1 3 5 7])&quot; &quot;(only-numbers? [1 2 3 4])&quot; &quot;(only-numbers? [1 2 :D 3 4])&quot; &quot;(only-numbers? [])&quot; &quot;(sequence-contains? 3 [1 2 3])&quot; &quot;(sequence-contains? 3 [4 7 9])&quot; &quot;(sequence-contains? :pony [])&quot; &quot;(my-take-while odd? [1 2 3 4])&quot; &quot;(my-drop-while odd? [1 2 3 4])&quot; &quot;(my-take-while odd? [1 3 4 5])&quot; &quot;(my-take-while even? [1 3 4 5])&quot; &quot;(my-take-while odd? [])&quot; &quot;(seq= [1 2 4] '(1 2 4))&quot; &quot;(seq= [1 2 3] [1 2 3 4])&quot; &quot;(seq= [1 3 5] [])&quot; &quot;(count [])&quot; &quot;(my-map + [1 2 3 4] [0 0 0])&quot; &quot;(my-map + [1 2 3] [])&quot; &quot;(power 2 2)&quot; &quot;(power 5 3)&quot; &quot;(my-map + [1 2 3] [4 4 4])&quot; &quot;(fib 0)&quot; &quot;(fib 1)&quot; &quot;(fib 2)&quot; &quot;(fib 3)&quot; &quot;(fib 4)&quot; &quot;(fib 5)&quot; &quot;(fib 6)&quot; &quot;(fib 7)&quot; &quot;(fib 1024)&quot;], :remote []}}</component>
</project>